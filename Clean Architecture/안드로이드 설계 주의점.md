## 안드로이드 설계 주의점


### 설계

하나의 엑티비티 혹은 프래그먼트에 단일 뷰 모델을 사용하게 될 경우 비지니스로직이 많아 지면 뷰 모델이
커지게(fat)되는데.. 이럴 경우 관련 로직들로 나누어 하나의 엑티비티 혹은 프래그먼트에 여러개의 뷰모델을 사용하는게 좋다.(이는 domain layer가 사용되는 이유와도 연관된다.)
뷰 모델 간의 상태공유가 필요한 경우에는 전역적인 공통뷰 모델을 가지고(activity 뷰모델 같은) 공유하거나 usecase등을 사용하여 공유하는 식으로 하면 된다.


### 안티패턴

상태가 유실 될 가능성이 있는 이벤트는 지양해야한다.
코루틴에 채널등과 같이 유실 위험이 있는 경우에 필수적인 정보를 공유하면 안된다.

UI코드에서 엑션까지 구현하는 것은 옳지 않다
로직은 뷰모델에서 처리 해야하고 UI는 이러한 처리 결과를 어떻게 반영할지만 정하면 된다.

다이얼로그와 같은 일회성 이벤트를 사용할 때 조심해야 된다.
이미 다이얼로그나 일회성 이벤트의 상태가 변경된 경우(화면 회전 등) 변경된 상태를 고려하여 개발해야 한다.

UI 상태 처리에 Compose의 State대신 StateFlow나 SharedFlow를 이용할 경우 오버헤드가 발생한다.

단순 컴포저블과 뷰모델의 연결은 State를 쓰는게 좋다. 물론 NetWork등과 같은 작업에서 발생하는 데이터는 StateFlow나 SharedFlow를 이용해야 한다.

컴포저블 함수를 만들게 되면 각각에 뷰 컴포넌트를 만들게 되는데 이는 스냅샷이라는 형태로 현재 상태가 저장이 된다. 여기에 그대로 연결되어 있는게 State인데 StateFlow등을 collectAsState등을 이용하여 오버헤드가 발생하기도 하고 리컴포지션 과정에서 불필요한 오버헤드가 발생하기도 한다.


뷰모델 생성자에서 초기화 이상의 일(네트워크를 불러온다거나 하는)을 하는 것은 안티 패턴이다
이러한 로직은 뷰모델 뿐만 아니라 어떠한 종류의 클래스라도 동일하게 적용된다.
단일 책임 원칙 위반(액터(호출자)가 누구인지 )
테스크 구현이 어려움
상속시 자식에게 과도한 정보의 습득을 요구
사용자에게 필요없는 초기화를 수행하지 않게 만들 선택권을 박탈

생성자에서 하면 좋지 않은 일: 다른 객체의 생성, 정적 메소드 호출, 필드에 단순 대입 이상의 로직 구현(if/when과 같은)
이러한 함수가 필요할 경우 lazy를 이용하여 초기화를 구현하면 된다.

아래와 같이 lazy를 이용하여 사용자가 필요로 하는경우 데이터를 반환하는게 좋다.

```
  private val users: MutableLiveData<List<User>> by lazy {
    MutableLiveData<List<User>>().also {
      loadUsers()
    }
  }
```

### 단방향 데이터 흐름

상위객체는 하위 객체로부터 상태를 읽을 수 없어야 한다.
하위 객체는 상위 객체의 이벤트를 직접 읽을 수 없고 상위 객체도 하위 객체로 직접 이벤트를 보낼 수도 없다

데이터 바인딩이 필요한 이유
순환이벤트 흐름 때문이다.
데이터 바인딩을 사용하지 않을 경우 클릭시 뷰모델에서 처리 후 다시 뷰에서 클릭을 전달받아 처리해야 하기 때문인다.

MVVM의 단점 Fat해질 수가 있고 순환 이벤트 흐름을 완전히 막기가 어렵다.