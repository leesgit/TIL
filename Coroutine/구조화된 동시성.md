# 구조화된 동시성 (Structured Concurrency)

> 코루틴의 생명주기를 계층적으로 관리하여 리소스 누수를 방지하는 원칙

## 핵심 개념

구조화된 동시성은 코루틴이 명확한 부모-자식 관계를 가지며, 부모 코루틴이 취소되면 모든 자식 코루틴도 취소되는 것을 보장한다.

### 3가지 원칙

1. **부모는 자식이 완료될 때까지 기다린다**
2. **부모가 취소되면 자식도 취소된다**
3. **자식의 예외는 부모에게 전파된다**

## 코드 예시

### CoroutineScope 계층

```kotlin
class HomeViewModel : ViewModel() {

    fun loadData() {
        viewModelScope.launch { // 부모 코루틴
            val user = async { getUser() }      // 자식 1
            val posts = async { getPosts() }    // 자식 2

            updateUi(user.await(), posts.await())
        }
        // viewModelScope 취소 시 모든 자식 취소됨
    }
}
```

### 위반 사례

#### GlobalScope 사용

```kotlin
fun loadData() {
    GlobalScope.launch {
        // ViewModel이 종료되어도 계속 실행됨
        // 메모리 누수, 불필요한 작업 발생
    }
}
```

**문제점:**
- 생명주기와 연결되지 않아 취소 불가
- 화면 종료 후에도 네트워크 호출 지속

#### 새 Job으로 분리

```kotlin
fun loadData() {
    viewModelScope.launch(Job()) {
        // 부모와 연결 끊어짐
        // viewModelScope 취소해도 이 코루틴은 계속 실행
    }
}
```

### 개선안: SupervisorJob 사용

```kotlin
class HomeViewModel : ViewModel() {

    fun loadMultipleData() {
        viewModelScope.launch {
            supervisorScope {
                val job1 = launch { loadSection1() } // 실패해도
                val job2 = launch { loadSection2() } // 계속 실행
                val job3 = launch { loadSection3() } // 계속 실행
            }
        }
    }
}
```

### coroutineScope vs supervisorScope

| 구분 | coroutineScope | supervisorScope |
|------|----------------|-----------------|
| 자식 실패 시 | 모두 취소 | 나머지 계속 실행 |
| 용도 | 연관된 작업 | 독립적 작업 |

```kotlin
// coroutineScope: 하나 실패하면 모두 취소
suspend fun loadAll() = coroutineScope {
    val a = async { loadA() } // 실패하면
    val b = async { loadB() } // 취소됨
}

// supervisorScope: 하나 실패해도 나머지 계속
suspend fun loadAll() = supervisorScope {
    val a = async { loadA() } // 실패해도
    val b = async { loadB() } // 계속 실행
}
```

## Android에서의 적용

### ViewModel

```kotlin
class MyViewModel : ViewModel() {
    // viewModelScope: ViewModel 종료 시 자동 취소
    fun fetch() = viewModelScope.launch {
        // 화면 회전해도 유지, onCleared()에서 취소
    }
}
```

### Lifecycle

```kotlin
class MyFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        // viewLifecycleOwner.lifecycleScope: View 종료 시 취소
        viewLifecycleOwner.lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    // STARTED~STOPPED 동안만 수집
                }
            }
        }
    }
}
```

### Compose

```kotlin
@Composable
fun MyScreen(viewModel: MyViewModel) {
    // rememberCoroutineScope: Composition 떠나면 취소
    val scope = rememberCoroutineScope()

    Button(onClick = {
        scope.launch {
            viewModel.submitForm()
        }
    }) {
        Text("Submit")
    }

    // LaunchedEffect: key 변경 또는 Composition 떠나면 취소
    LaunchedEffect(userId) {
        viewModel.loadUser(userId)
    }
}
```

## 면접 포인트

- **Q: 구조화된 동시성이란 무엇인가요?**
- A: 코루틴이 부모-자식 계층 구조를 가지며, 부모 취소 시 자식도 취소되고, 부모는 자식 완료를 기다리는 원칙이다. 이를 통해 리소스 누수를 방지하고 예외 처리를 명확하게 할 수 있다.

- **Q: GlobalScope를 왜 피해야 하나요?**
- A: GlobalScope는 애플리케이션 전체 생명주기를 가져서 구조화된 동시성을 깨뜨린다. 화면 종료 후에도 작업이 계속 실행되어 메모리 누수, 불필요한 네트워크 호출이 발생할 수 있다.

- **Q: SupervisorJob은 언제 사용하나요?**
- A: 여러 독립적인 작업을 병렬 실행할 때 사용한다. 하나의 자식 실패가 다른 자식에게 영향을 주지 않아야 할 때, 예를 들어 여러 섹션을 동시에 로드하는 화면에서 유용하다.

## 참고

- [Kotlin Coroutines: Structured Concurrency](https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency)
- [Android Coroutines Best Practices](https://developer.android.com/kotlin/coroutines/coroutines-best-practices)
